#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: The Rust Programming Language
#+date: <2024-02-29 周四>
#+author: ysouyno
#+email: ysouyno@163.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 29.2 (Org mode 9.6.15)
#+cite_export:

* 我的理解

** 第 7.1 节 <2024-03-02 周六>

怎么没有人问问这句话怎么理解吗？为什么我用 Rust 创建了一个 Package，这
个 Package 只能包含一个 library crate 呢？我记得在 Cargo.toml 不是可以
包含很多个 library crate 依赖嘛？没有听说最多只能包含一个呀？

#+begin_quote
A package can contain as many binary crates as you like, but at most
only one library crate. A package must contain at least one crate,
whether that’s a library or binary crate.
#+end_quote

难道只有我一个人理解错了？我想这应该是中英文的翻译和理解问题吧！需要注
意这里的“包含”不是指 c++ 里的 include，而只是 contain。这句话要表达
的意思应该是：新建了一个 Rust 的 Package，这个 Package 里可以新增很多
个 crate，但是最多只能有一个 crate 是 library。

* 容易忘记的知识点

** 第 3.2 节 <2024-02-29 周四>

Rust 中的 ~char~ 类型是四字节长度，与我们平时以 c++ 的认知是不一样的。

#+begin_quote
Rust’s char type is four bytes in size and represents a Unicode
Scalar Value, which means it can represent a lot more than just
ASCII. Accented letters; Chinese, Japanese, and Korean characters;
emoji; and zero-width spaces are all valid char values in
Rust. Unicode Scalar Values range from U+0000 to U+D7FF and U+E000 to
U+10FFFF inclusive. However, a “character” isn’t really a concept
in Unicode, so your human intuition for what a “character” is may
not match up with what a char is in Rust.
#+end_quote

没有任何值的元组有一个特殊的名称 ~unit~ 。此值及其对应的类型都是 ~()~
，并表示空值或空返回类型。表达式如果不返回任何其他值，则隐式返回
~unit~ 。

** 第 3.3 节 <2024-02-29 周四>

整个 ~fn~ 函数就是一个 ~statement~ ，调用函数是一个 ~expression~ ，调
用一个宏是一个 ~expression~ ，花括号括起来的代码块是一个 ~expression~
（最后一个语句不能加分号）。

** 第 4.1 节 <2024-03-01 周五>

有两个特性要注意： ~Copy~ 和 ~clone~ ， ~Copy~ 用于栈上的类型，比如整
形， ~clone~ 用于堆上的类型，比如 ~String~ 。

如果一个类型实现了 ~Copy~ 特性，使用它的变量不会移动，而是简单地复制，
使它们在赋值给另一个变量后仍然有效。如果类型或其任何部分实现了 ~Drop~
特性，Rust 将不允许我们用 ~Copy~ 注释类型。

#+begin_quote
To learn about how to add the Copy annotation to your type to
implement the trait, see “Derivable Traits” in Appendix C.
#+end_quote

将变量传递给函数同样也会移动；返回值也可以转移所有权。

#+begin_src rust
  fn main() {
      let mut s = String::from("hello");

      let r1 = &s; // no problem
      let r2 = &s; // no problem
      let r3 = &mut s; // BIG PROBLEM

      println!("{}, {}, and {}", r1, r2, r3);
  }
#+end_src

请注意，引用的作用域从它被引入的地方开始，一直持续到最后一次使用该引用
的时候。

** 第 5.3 节 <2024-03-01 周五>

结构体方法里的 ~&self~ 参考，实现就是 ~self: &Self~ 的简写。

** 第 7.3 节 <2024-03-02 周六>

父模块中的项不能使用子模块中的私有项，但子模块中的项可以使用其祖先模块
中的项。

结构体除了设置整个为 ~pub~ ，还要设置每个成员的可见属性，而对于枚举类
型则不需要设置成员的可见属性，因为结构体成员默认是 ~private~ 的，而枚
举成员默认则是 ~public~ 的。

#+begin_src rust
  pub struct Breakfast {
      pub toast: String,
      seasonal_fruit: String,
  }
#+end_src

** 第 8.1 节 <2024-03-03 周日>

请注意下面这段代码是存在错误的：

#+begin_src rust
  fn main() {
      let mut v = vec![1, 2, 3, 4, 5];
      let first = &v[0];
      v.push(6);

      println!("The first element is: {first}");
  }
#+end_src

因为 ~vector~ 可能会随着长度的增加而申请更大的内存，所以 ~first~ 可能
会指向已经释放的内存。

对于 ~String~ 来说，按照索引来取它的单个字符是不合法的，因为它内部是
~utf-8~ 编码，但是如果要迭代输出整个 ~String~ 的话，有两种方式，
~chars~ 和 ~bytes~ ，见测试代码：

#+begin_src rust
  fn main() {
      let s = "你好";

      print!("{} as chars: ", s);
      for i in s.chars() {
          print!("{} ", i);
      }
      print!("\n{} as bytes: ", s);
      for i in s.bytes() {
          print!("{} ", i);
      }
      println!();
  }
#+end_src

#+begin_src text
  你好 as chars: 你 好
  你好 as bytes: 228 189 160 229 165 189
#+end_src

** 第 9.2 节 <2024-03-03 周日>

此节真的好长！

我之前经常使用的 ~unwrap~ ，对它还是不太了解，在这里可以有两点：

1. ~unwrap~ 如果失败，程序会直接 panic。
2. ~expect~ 和 ~unwrap~ 一样，只不过 ~expect~ 可以自定义文本。

*** DONE 尝试创建 ~OurError~ <2024-03-03 周日> <2024-03-04 周一>

这节里提到的 ~From~ 特性，并提到可以使用自定义的 ~OurError~ ，并为它实
现 ~impl From<io::Error> for OurError~ 特性，我觉得我有时间可以尝试一
下。

下面是我的尝试代码及输出：

#+begin_src rust
  #![allow(unused)]
  use std::fs::File;
  use std::io::{self, Read};

  #[derive(Debug)]
  struct OurError {
      desc: String,
  }

  impl From<io::Error> for OurError {
      fn from(value: io::Error) -> Self {
          OurError {
              desc: format!("From io::Error {} to OurError.", value),
          }
      }
  }

  fn read_username_from_file() -> Result<String, OurError> {
      let mut username_file = File::open("hello.txt")?;
      let mut username = String::new();
      username_file.read_to_string(&mut username)?;
      Ok(username)
  }

  fn main() {
      read_username_from_file().unwrap();
  }
#+end_src

程序输出：

#+begin_src text
  thread 'main' panicked at src\main.rs:26:31:
  called `Result::unwrap()` on an `Err` value: OurError { desc: "From io::Error 系统找不到指定的文件。 (os error 2) to OurError." }
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
#+end_src

*** TODO ~Result~ 好像可以和 ~Option~ 相互转化 <2024-03-03 周日>

#+begin_quote
The ? operator won’t automatically convert a Result to an Option or
vice versa; in those cases, you can use methods like the ok method on
Result or the ok_or method on Option to do the conversion explicitly.
#+end_quote

** 第 10.3 节 <2024-03-04 周一>

生命周期就像模板参数一样！
